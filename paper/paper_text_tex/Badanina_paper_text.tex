\documentclass{article} 
\usepackage[utf8]{inputenc}
\usepackage[T2A]{fontenc}
\usepackage[russian, english]{babel}
\usepackage{graphicx}	
\usepackage{amsmath, amssymb}
\usepackage{titlesec}
\newcommand\tab[1][1cm]{\hspace*{#1}}
\usepackage[14pt]{extsizes}
\usepackage{setspace,amsmath}
\usepackage[left=20mm, top=15mm, right=15mm, bottom=15mm, nohead, footskip=10mm]{geometry} 
\usepackage{mathtext}
\usepackage[dvipsnames]{xcolor}
\usepackage{ragged2e}
\sloppy
\usepackage{caption}
\usepackage{hyperref}

\hypersetup{
    colorlinks=true,
    linkcolor=black,
    urlcolor=blue
}
%--------------------------------------------------------------------
\begin{document}                                                         
\newpage
\thispagestyle{empty}

\begin{center}
Федеральное государственное образовательное бюджетное учреждение\\ высшего профессионального образования\\ 
\textbf{«Финансовый университет при Правительстве Российской Федерации»}\\
\end{center}
	
\vspace{2em}
	
\begin{center}
\textbf{Департамент анализа данных, принятия решения и финансовых технологий}\\ 
\end{center}
	
\vspace{2em}
	
\begin{center}
\textbf{Курсовая работа\\
\vspace{3mm}}
по дисциплине \textbf{"Технологии анализа данных и машинное обучение"} на тему: \\ \vspace{2em} \textbf{"Разработка и построение рекомендательной системы"}\\
\vspace{3mm}
Вид исследуемых данных: Рейтинг и история просмотра пользователей аниме-сериалов\\
\end{center}
	
\vspace{6em}
		
\begin{flushright}
Выполнила:\\
студентка группы ПМ3-1\\
Баданина Н. Д.\\
Научный руководитель:\\
к.э.н., доцент\\
Гринева Наталья Владимировна
\end{flushright}
	
\vspace{\fill}
	
\begin{center}
Москва 2020
\end{center}

%--------------------------------------------------------------------
\newpage
	
\renewcommand*\contentsname{Содержание}
\makeatletter
\renewcommand{\l@section}{\@dottedtocline{1}{0em}{2em}}
\renewcommand{\l@subsection}{\@dottedtocline{1}{0em}{2.6em}}
\renewcommand{\l@subsubsection}{\@dottedtocline{1}{0em}{3.2em}}

\makeatother
\setcounter{page}{2}

\begin{center}
	\tableofcontents
\end{center}

%--------------------------------------------------------------------
\newpage
%\addcontentsline{toc}{section}{Введение}
\section{Введение}
\tabДолгое время маркетинг был традиционным. До появления современных технологий продавец в локальном магазине знал о своих покупателях гораздо больше, чем требовалось для продажи. Можно сказать, что предложения продавца покупателю были персонализированными или таргетинговыми. \\
\tabС развитием современных технологий и экстенсивным ростом индустрии, большие бизнесы, получающие доход с продаж, уже не знают своих клиентов лично. Обычно о клиенте известные общая информация, например пол или регион проживания. На этом этапе появляется не персонализированная реклама: баннеры, вывески. Телевидение, несмотря на свой охват, тоже предлагает не таргетинговую рекламу. На основе данных об аудитории канала рекомендации будут неэффективные: слишком общие или неактуальные. \\
\tabПроблема сбора данных решается с появление сети Интернет. Сейчас о пользователе можно узнать геопозицию, каким телефоном и браузером он пользуется, личные данные и увлечения из профилей социальных сетей. Особенностью сбора данных через интернет является то, что пользователь сам указывает начальную информацию о себе: ФИО, город, номер телефона. Остальные данные получают исходя из поведения клиента. 
Однако, и при этом подходе, рекомендации могут быть слабо персонализированными в силу специфичности данных. На этом моменте построения рекомендаций необходимо применять алгоритмы машинного обучения, которые, обработав массив данных о пользователе, могут сделать неочевидный вывод о том, какой товар или услугу можно продать клиенту.\\
\tabАлгоритмы машинного обучения, которые предсказывают какой фильм/статью/товар/услугу купит пользователей называют рекомендательными системами. В основном такие системы используются для рекомендаций фильмов (Netflix, YouTube), товаров (Яндекс.Маркет, Ozon), музыки (Яндекс.Музыка) и статей (Яндекс.Дзен). \\
\tab\includegraphics[scale=0.30]{f1.png}\\
\tabНапример, так выглядят рекомендации к товару Iphone 11 Pro на Яндекс.Маркет. Можно заметить недоработку: рекомендуют купить чехол к другой модели телефона.\\
\tabКлиент получает рекомендацию, а сервис зарабатывает на предоставлении услуг. Услуги в данном контексте не обязательно значат продажи предлагаемого товара. Сервис имеет возможность зарабатывать на комиссионных, показе рекламы или увеличивать лояльность пользователей, которые потом будут покупать только в этом магазине. Интересно, что даже страницы в поиске сейчас персонализированы и разным пользователям по одному и тому же запросу могут быть предложены разные ссылки на сайты.\\
\tabВ данной работе рассмотрено построение рекомендательной системы для совета аниме-сериала пользователю. По оценкам McKinsey, $75\%$ выручки онлайн кинотеатра Netflix приходится именно на рекомендованные фильмы/сериалы и процент этот, вероятно, будет расти. Рынок японских анимационных сериалов только развивается в России, поэтому система будет актуальная для многих сервисов, таких как Ivi, Okko и Кинопоиск, которые ещё не внедрили контент этого типа на свои платформы.\\
\qquad 

%--------------------------------------------------------------------
\newpage
\section{Обзор методов и алгоритмов рекомендательных систем}
\tabРекомендательные сервисы многообразны, так как их основные характеристики могут сильно отличаться. Любую рекомендательную систему можно описать с помощью таких характеристик, как \\
\tab– предмет рекомендации: товары (Ozon, Amazon), статьи (Яндекс.Дзен), новости (Surfingbird), люди (Linkedin, LonelyPlanet), музыка (Last.fm, Pandora), плейлисты и так далее. Обобщая, рекомендовать можно что угодно. \\
\tab– цель. Для чего рекомендуется: информирование, покупка, обучение. \\
\tab– контекст. Чем пользователь в этот момент занимается: смотрит товары, читает статью, слушает музыку. \\
\tab– источник рекомендации. Кто рекомендует: схожие по интересам пользователи, аудитория (средний рейтинг ресторана в TripAdvisor), экспертное сообщество (такой случай встречается, когда речь идет о сложном товаре, таком, как например, вино).\\
\tab– глубина персонализации. Неперсональные рекомендации – пользователю рекомендуют те же товары, что и всем остальным. Такие предложения допускают таргетинг по времени или региону, но не учитывают личные предпочтения и историю клиента. Более лучший вариант – рекомендации используют данные из текущей сессии. Пользователь смотрел некоторые товары, ему предлагаются похожие. Персональные рекомендации используют всю доступную информацию о клиенте, в том числе историю его покупок.\\
\tab– прозрачность. Клиенты больше доверяют рекомендации, если понимают, как почему именно она была показана. Так меньше риск встретить некачественные системы, продвигающие проплаченный товар или ставящие более дорогие товары выше в рейтинге. Кроме того, хорошая система сама должна уметь бороться с купленными отзывами и накрутками продавцов. Манипуляции бывают и непреднамеренными. Например, когда выходит новый блокбастер, первым делом на него идут фанаты, соответственно, первую пару месяцев рейтинг может быть сильно завышен.\\
\tab– формат рекомендации. Это может быть всплывающее окно, лента внизу экрана, появляющийся в определенном разделе сайта список.\\
\tab– алгоритмы. К наиболее классическим относятся алгоритмы Content-based (модели основанные на описании товара), Summary-based (неперсональные), Matrix Factorization (методы основанные на матричном разложении), Collaborative Filtering (коллаборативная фильтрация). Некоторые из них были реализованы в разделе практики.
%--------------------------------------------------------------------
\newpage
\subsection{Постановка задачи}
\tabЗадача рекомендательной системы — найти для пользователя такие элементы из заданного множества, которые с высокой вероятностью ему понравятся. Например: товары, которые пользователь захочет купить; фильмы, которые пользователю понравятся; статьи, которые пользователь дочитает до конца.\\
\tabВведем некоторые стандартные обозначения. Пользователи — множество $﻿U$ (users). В этой работе в множество ﻿$U$ попадают пользователи сайта, поставившие какому-либо аниме-сериалу оценку. Новые пользователи рассматриваться не будут, так как возникает проблема "холодного старта", при которой у программы недостаточно информации для рекомендации. Подробно эта проблема будет рассмотрена в разделе "Проблематика".\\
\tabТовары — множество ﻿$I$﻿ (items). В множестве $I$ могут быть любые категории товаров: и фильмы, и музыка, и техника — зависит от задачи. В этой работе в качестве множества $I$ выступает список аниме-сериалов. Так же будем считать, что для некоторой пары пользователь-товар ﻿$u\in U$ и $i\in I$﻿﻿ известна оценка $r_{ui}$, выражающая заинтересованность пользователя в этом товаре.\\
\tabЗаинтересованность может выражаться в разных единицах. В случае с музыкой, это может быть как много раз пользователь слушал данный трек, как много раз дослушал до конца, лайкнул ли он его. В случае со статьями, дочитал ли он текст до конца, сколько раз кликнул, скорость проматывания страницы. В данной работе заинтересованность принимает вид рейтинга, поставленного пользователем аниме-сериалу и находящегося в промежутке от 1 до 10.\\
\tabТребуется по известным оценкам заинтересованности научиться находить для каждого пользователя $u$ набор из ﻿$k$ товаров ﻿$I(u)$, наиболее подходящих пользователю, то есть таких, для которых оценка ﻿$r_{ui}$ окажется максимальной. Следовательно, в итоге, задача сводится к тому, что для объекта вида ﻿$x_{ui}$ надо уметь предсказывать оценку $r_{ui}$. Как и в любой задаче машинного обучения, требуется уточнить три пункта: целевая переменная, признаки, функционал ошибки. Первый пункт был рассмотрен выше. Необходимо рассмотреть признаки, характеризующие пару пользователь-товар.
%--------------------------------------------------------------------
\newpage
\subsection{Статистические признаки}
\tabРассмотрим простые типы факторов. Среди них могут быть: количество покупок и просмотров данного товара, количество покупок пользователя в данной категории, количество покупок пользователей.\\
\tabЕсли товар или пользователь уже набрали достаточно статистики, то часто такие признаки оказываются самыми главными при принятии решения, поскольку уже содержат в себе достаточно информации о предпочтениях. Так, используя эти признаки, можно рекомендовать популярные товары в той категории, что нравится пользователю.

%--------------------------------------------------------------------
\subsection{Коллаборативная фильтрация}
\tabМетоды коллаборативной фильтрации строят рекомендации для пользователя на основе схожести между пользователями и товарами. Различают несколько подходов:\\
\tab— Memory-based\\
\tab— Модели со скрытыми переменными\\
\tab— Гибридный: объединение вышеперечисленных подходов.\\
\tabРассмотрим memory-based подход. В его основе лежит таблица $R$, ﻿размерности $N\times M$, где ﻿$N$﻿ — количество пользователей, а $M$— количество товаров. Это матрица, по одной из осей которой отложены все клиенты сервиса (Users), а по другой – объекты рекомендации (Items). На пересечении некоторых пар (user, item) данная матрица заполнена оценками (Ratings) – это известный показатель заинтересованности пользователя в данном товаре, выраженный по заданной шкале (например от 1 до 10). На пересечении строки $u$ и столбца ﻿$i$﻿ хранится значение ﻿$r_{ui}$﻿, если оно известно. Здесь стоит отметить, что, в основном, такая матрица будет состоять из нулей или пропусков, так как товаров много, а процент покупок, в отношении к количеству позиций, маленький. Вытекающим из этого замечания является вывод о том, что в программе необходимо хранить всю матрицу рейтингов, которая имеет большую размерность. Это не только в разы увеличивает время работы, но и усложняет визуализацию и процесс вычислений с использованием этой матрицы. \\
\tabПользователи обычно оценивают всего лишь малую часть товаров и задача рекомендательной системы – обобщить эту информацию и предсказать отношение клиента к другим товарам, про которые ничего не известно. Иными словами нужно заполнить все пустующие ячейки. Паттерны потребления у людей разные, следовательно система необязательно должна рекомендовать новые товары. Можно показывать повторяющиеся товары, например, для пополнения запаса. Исходя их этого принципа выделяют две группы товаров: повторяемые и неповторямые, например неповторямые – это книги или фильмы, которые редко приобретают повторно. Выделяя повторяемые товары в категорию можно сократить размерность матрицы $R$.\\
 \tab\includegraphics[scale=0.6]{f2.png}\\
 \tabМатрица $R$.\\
 \tabНекоторым пользователи покупают вещи только из их любимой категорий (conservative recommendations), а некоторые, напротив, лучше откликается на нестандартные товары или группы товаров (risky recommendations). Например, онлайн кинотеатр может рекомендовать пользователю только новые серии конкретного сериала, а может показывать новые шоу или новые жанры.\\
%--------------------------------------------------------------------
\subsection{Baseline}
\tabСамое простое предсказание, которое можно сделать, имея таблицу ﻿$R$﻿, посчитать среднее всех известных оценок и считать, что и остальным товарам пользователи будут ставить именно такие оценки:\\
\\
\tab$\mu=\frac{\sum_U{\sum_I{r_{ui}}}}{|Y|}$, где $Y$ — множество известных оценок.\\ 
\\
\tabНо понятно, что такой подход имеет множество недостатков, один из них заключается в том, что не учитывается предвзятость пользователей и популярность товаров. Для того, чтобы учесть данные характеристики, найдем среднюю оценку для каждого товара и для каждого пользователя:\\
\\
\tab$\mu_i=\frac{\sum_U{r_{ui}}}{n_i}$\\
\\
\tab$\mu_u=\frac{\sum_I{r_{ui}}}{m_u}$, где ${n_i}$ и ${m_u}$ — количество оценок у товара $i$﻿ и пользователя ﻿$u$ соответственно.\\
\tabПосчитав сдвиги для пользователей и товаров относительно средней оценки, можно более точно вычислить, какую оценку пользователь ﻿$u$﻿ поставит товару $i$﻿﻿:\\
\tab$b_i=\mu_i-\mu$\\
\tab$b_u=\mu_u-\mu$\\
\tab$r_{ui}=\mu+b_i+b_u$\\
\\
\tabОднако, при этом подходе никак не учитывается схожесть пользователей. Получается, что при подсчете средней оценки на неё влияли как пользователи со схожими вкусами, так и те, вкусы которых сильно разнятся. Поэтому необходимо модифицировать подсчет среднего: считать среднее для всех товаров для выбранного пользователя ﻿$u_0$, при этом влияние других пользователей будет зависеть от их схожести с выбранным пользователем $sim(u_0,u)$:\\
\\
\tab$\mu=\frac{\sum_U{sim(u_0,u)}\sum_I{r_{ui}}}{|Y|}$\\
\\
\tabСоответственно также можно модифицировать подсчет средней оценки для товаров.
%--------------------------------------------------------------------
\subsection{Сравнение пользователей и товаров}
\tabВозникает вопрос: как сравнивать схожесть пользователей. Необходимо исходить из следующего предположения: два пользователя считаются похожими, если они ставят одним и тем же товарам одинаковые оценки. Рассмотрим двух пользователей ﻿$u$﻿ и ﻿$v$﻿. Обозначим через ﻿$I_{uv}$ множество товаров ﻿$i$, для которых известны оценки обоих пользователей:\\
\\
\tab$I_{uv}=\{ i\in I | \exists r_{ui} \& \exists r_{vi}\}$\\
\\
\tabТогда сходство между двумя данными пользователями можно вычислить с помощью корреляции Пирсона:\\
\\
\tab$sim(u,v)=\frac{\sum_{i\in I_{ui}}{(r_{ui}-\mu_u)(r_{vi}-\mu_v)}}{\sum_{i\in I_{uv}}{(r_{ui}-\mu_u)^2}\sum_{i\in I_{uv}}{(r_{vi}-\mu_u)^2}}$\\
\\
\tabОсновной минус расчета по корреляции Пирсона —  корреляция может иметь большое значение случайно. Чтобы предотвратить завышение корреляции можно домножить корреляцию Пирсона на коэффициент, значение которого уменьшается с ростом числа оценок.\\
\tabЧтобы вычислить сходство между товарами $i$﻿ и ﻿$j$﻿ также введем множество пользователей ﻿$U_{ij}$﻿, для которых известны оценки для этих товаров.\\
\\
\tab$U_{uj}=\{u\in U|\exists r_{ui} \&\exists r_{uj}\}$\\
\\
\tabТогда сходство двух товаров можно вычислить через корреляцию Пирсона:\\
\\
\tab$sim(i,j)=\frac{\sum_{u\in U_{ij}}{(r_{ui}-\mu_i)(r_{uj}-\mu_j)}}{\sum_{u\in U_{ij}}{(r_{ui}-\mu_i)^2}\sum_{u\in U_{ij}}{(r_{ui}-\mu_j)^2}}$\\
\\
\tabМожно применять и другие способы вычисления схожестей. Например, вычислить норму разности между векторами или скалярное произведение векторов.\\
\tabСуществует три метода, использующих сходство пользователей или товаров:
\tab– Тривиальные рекомендации;\\
\tab– Подход на основе сходств пользователей (user-based collaborative filtering);\\
\tab– Подход на основе сходств товаров (item-based collaborative filtering).
%--------------------------------------------------------------------
\subsection{Тривиальные рекомендации}
\tabПусть пользователю ﻿$u_o$ понравился товар $i_0$. Найдем множество пользователей, которым также понравился этот товар:\\
\\
\tab$U(i_0)=\{u\in U|\exists r_{ui_0}\}$\\
\\
\tabДалее среди товаров, купленных пользователями из множества ﻿$U(i_0)$ найдем те, которые наиболее похожи на исходный товар:\\
\\
\tab$I(i_0)=\{i\in I|sim(i_0, i)>\alpha \quad \exists r(u, i), u\in U(i_0)\}$\\
\\
\tabПользователю рекомендуется ﻿$k$ товаров из множества ﻿$I(i_0)$ с максимальным значением $sim(i_0,i)$.\\
\tabУ такого подхода есть ряд проблем. Так, например, все рекомендации будут тривиальные, то есть в основном будут рекомендоваться популярные товары. Также не учитываются интересы конкретного пользователя ﻿$u_0$. Однако, всегда можно будет порекомендовать конкретный объект нетипичным пользователям, несмотря на то, что это будет популярный товар.
%--------------------------------------------------------------------
\subsection{Подход на основе сходств пользователей. User-based collaborative filtering}
\tabРассмотрим второй подход. Классическая реализация алгоритма основана на принципе $k$ ближайших соседей. Для каждого пользователя ищется k наиболее похожих на него (в терминах предпочтений) и дополняется информацией о пользователе известными данными по его соседям. Допустим, необходимо сделать рекомендации для фиксированного пользователя $u_0$. Найдем множество ﻿$U(u_0)$ пользователей, похожих на данного:\\
\\
\tab$U(u_0)=\{u\in U|sim(u_0,u)>\alpha\}$, где ﻿$\alpha$ заданный порог схожести.\\
\\
\tabПосле этого для каждого товара вычислим, как часто пользователи из множества $U(u_0)$ покупали его:\\
\\
\tab$p_i=\frac{|\{u\in U(u_0)|\exists r_ui\}|}{|U(u_0)|}$\\
\\
\tabПользователю рекомендуется ﻿$k$ товаров с максимальными значениями ﻿$p_i$. Таким образом, будет вероятность рекомендовать не только самые популярные товары, но и те, что популярны среди данного типа пользователей. Также в таком подходе учитываются интересы пользователя $u_0$﻿.\\
\tabПроблема данного подхода заключается в том, что он позволяет строить рекомендации только в том случае, если для данного пользователя существуют похожие на него. Если же пользователь новый или нетипичный, то подобрать что-либо не получится. У такой реализации алгоритма существует недостаток – он плохо применим на практике из-за квадратичной сложности. Действительно, при реализации метода ближайшего соседа, требуется расчет всех попарных расстояний между пользователями (их может быть миллионы).
%--------------------------------------------------------------------
\subsection{Подход на основе сходств товаров. Item-based collaborative filtering}
\tabПоследний подход основан на сходстве товаров. Подход Item-based является альтернативой классическому подходу User-based, описанному выше, и почти полностью его повторяет, за исключением одного момента — применяется он к транспонированной матрице предпочтений, то есть ищет близкие товары, а не пользователей. Для него определяется множество товаров, похожих на те, которые интересовали пользователя ﻿$u_0$:\\
\\
\tab$I(u_0)=\{i\in I|\exists r_{u_0i_0}, sim(i_0,i)>\alpha \}$, где ﻿$\alpha$ заданный порог схожести\\
\\
\tabДалее для каждого товара из найденного множества вычисляется его сходство с товарами из множества пользователя:\\
\\
\tab$p_i=max i_0: \exists r_{u_0i_0},sim(i_0,i)$\\
\\
\tabПользователю рекомендуется ﻿$k$ товаров с наибольшими значениями $p_i$﻿. В таком подходе решается проблема нетипичного пользователя, так как необязательно иметь пользователей со схожими интересами, и подход позволяет найти товары, похожие на интересные ему. Однако, существуют и проблемы: есть вероятность, что вместо действительно интересных товаров будут рекомендоваться популярные.\\
\tabПри использовании item-based подхода рекомендации имеют свойство быть консервативными. Действительно, разброс рекомендаций получается меньше и, следовательно, меньше вероятность показать нестандартные товары. В item-based подходе сложность вычислений снижается, так как необходимо хранить матрицу схожести товаров, а в большинстве случаев, товаров меньше, чем пользователей и соответсвенно размер матрицы будет меньше. Оценка близости товаров гораздо более точная, чем оценка близости пользователей. Это прямое следствие того, что пользователей обычно намного больше, чем товаров и, следовательно, стандартная ошибка при расчете корреляции товаров там существенно меньше. У алгоритма больше информации, чтобы сделать вывод. Предпочтения пользователя могут меняться со временем, но описание товаров гораздо более устойчивы. В user-based варианте матрица сильно разрежена, то есть преобладают нулевые элементы. Из-за этого список товаров, которые в итоге можно порекомендовать, получается очень небольшим.\\
\tabДругая возможная модификация — при вычислении item similarity взвешивать пользователей. Например, чем больше пользователь сделал оценок, тем больший у него вес при сравнении двух товаров.
%--------------------------------------------------------------------
\section{Проблематика}
\tabВсе перечисленные выше подходы имеют такие проблемы, как:\\
\tab— Не хватает теоретического обоснования;\\
\tab— Необходимо хранить всю матрицу рейтингов ﻿$R$;\\
\tab— Проблема холодного старта.\\
\tabСуществует множество способов измерить схожесть пользователей и товаров. Например, корреляция Спирмана, косинусное расстояние. Также существует большое множество гибридных методов, учитывающих преимущества подходов. Но без теоретического обоснования подходов сложно точно определить, какой подход где лучше использовать. Обычно, ответ на этот вопрос можно узнать только на практике.\\
\tabПроблема холодного старта заключается в том, что накоплено недостаточное количество данных для корректной работы рекомендательной системы. Например, непонятно, что рекомендовать новоприбывшему пользователю или кому нужно рекомендовать новый или редко покупаемый товар. От этой проблемы страдают большинство подходов в рекомендательной системе, так что эта проблема остается до сих пор актуальной. Проблема холодного старта также актуальна и для неперсонализированных рекомендаций. Общий подход здесь — заменять то, что в данный момент не может быть посчитано, различными эвристиками (например, заменять средним рейтингом или не использовать товар, пока не соберутся данные).\\
\tabЕдинственная действительно разрешимая проблема — необходимость хранить всю матрицу рейтингов ﻿$R$. Существуют подходы, помогающие уменьшить размерность матрицы.\\
\tabПомимо проблем у рассмотренных подходов есть и преимущества:\\
\tab— Легко понять;\\
\tab— Легко реализовать.\\
\tabБлагодаря этим сильным плюсам, зачастую memory-based подходы используют в качестве baseline.
%--------------------------------------------------------------------
\subsection{Контентные модели. Content-based recommendations}
\tabВ коллаборативной фильтрации учитывается информация о вкусах пользователей и об их сходствах, но при этом никак не используется свойства самих пользователей и товаров. При этом может быть полезным находить товары, похожие описанием на те, которыми пользователи интересовались. В рамках данного подхода описание товара (content) сопоставляется с интересами пользователя, полученными из его предыдущих оценок. Чем больше товар этим интересам соответствует, тем выше оценивается потенциальная заинтересованность пользователя. Очевидное требование здесь — у всех товаров в каталоге должно быть описание. Особенно видна польза такого подхода в рекомендательных системах, где пользователям предлагают видео, музыку или статьи. Скорее всего пользователю, любящему электронную музыку, захочется послушать не только то, что нравится другим электронщикам, но и то, что по звучанию похоже на его любимых исполнителей. \\
\tabПри таком подходе все товары описываются векторами, называемыми эмбедингами (embeddings). Затем измеряется сходство между вектором нового товара и векторами товаров из истории пользователя: можно вычислять как минимальное, так и среднее расстояние до векторов из истории. Однако, не все элементы необходимо включать в модель: например, союзные слова, не несут никакой смысловой нагрузки и могут быть удалены. Поэтому при определении числа совпадающих элементов в двух векторах все измерения нужно предварительно взвешивать по их значимости. Данная задача решается преобразованием TF-IDF, которое ставит больший вес более редким интересам. Совпадение таких интересов имеет большее значение при определении близости двух векторов, чем совпадение популярных.\\
\tabОчевидно, существует множество методов учета данных о пользователях и товарах, но никогда нельзя предсказать заранее, какой из них подойдет в данной задаче. При формировании вектора представления товара, вместо единичных слов можно использовать n-граммы (пары слов, тройки и т.д.). Такое дополнение сделает модель более точной, однако, потребуется больше данных и времени для обучения. Описания товара от можно взвешивать по-разному. Например, давать больший вес активным пользователям, у которых много оценок. Аналогично такой подход можно применить и к товару. Чем больше средний рейтинг, тем больше его вес.
%--------------------------------------------------------------------
\newpage
\section{Функционал ошибки}
\tabКак говорилось ранее, еще один важный пункт, который следует установить в любой задаче машинного обучения, это функционал ошибки. Существует довольно большое множество метрик качества рекомендательных систем. Различают онлайн-метрики и оффлайн-метрики.\\
\tabОнлайн-метрика — метрика, ключевая с точки зрения бизнеса. Например, это может быть среднее время, проведенное пользователем на сайте, или средний чек пользователя. Затем выбирают оффлайн-метрику или линейную комбинацию оффлайн-метрик, которая лучше всего коррелирует с выбранной бизнес метрикой.\\ 
\tabПод онлайн-метрикой понимается показатель, который можно измерить только при запуске рекомендательной системы на реальных пользователя, а под оффлайн-метрикой — показатель, который можно измерить для модели на исторических данных. Так же иногда пытаются найти промежуточную метрику, которая коррелирует с основной, но при этом быстро реагирует на изменения в работе рекомендательной системы.\\
%--------------------------------------------------------------------
\subsection{Качество предсказания событий}
\tabРассмотрим несколько оффлайн-метрик. Поскольку модель обучается для предсказывания $r_{ui}$, логично оценивать качество решения именно этой задачи.\\
\tabЕсли модель предсказывает рейтинг, время нахождения на странице или любую другую вещественную величину, то качество рекомендаций может быть измерено с помощью ﻿MSE﻿, ﻿RMSE, ﻿MAE﻿ или другие регрессивных метрик.\\
\tabЕсли модель предсказывает вероятность клика на статью, покупки товара, лайка или наступления любого другого события, то качество можно измерить с помощью метрик качества классификации: доля правильных ответов, точность, полнота, F-мера, AUC-ROC, log-loss.\\
\tabЕсли вспомнить, что мы показываем пользователю только ﻿$k$﻿ товаров, получивших самые высокие предсказания модели, то можно понять, что интересует качество только для этих товаров. Если через ﻿$R_u(k)$ обозначить предсказание для пользователя и ﻿$k$ товаров, а через $L_u$ - товары, для которых действительно произошло интересующее нас событие, то можно ввести следующие метрики:\\
\tabНаличие верной рекомендации:\\
\tab\tab$hitrate@k=[R_u(k)\cap L_u \neq 0]$\\
\\
\tabТочность:\\
\tab\tab$precision@k=\frac{|R_u(k)\cap L_u|}{|R_u(k)|}$\\
\\
\tabПолнота:\\
\tab\tab$recall@k=\frac{|R_{u}(k)\cap L_{u}|}{|L_{u}|}$\\
%--------------------------------------------------------------------
\subsection{Покрытие пользователей}
\tabСложно говорить о том, насколько хорошо работает рекомендательная система,
основываясь только на качестве предсказаний. Возможно, пользователь купил бы
товары, предсказанные моделью, и без её помощи. Поскольку нельзя узнать, повлияло ли предсказание модели на поведение пользователя, имеет смысл анализировать
и другие метрики качества, которые могут косвенно говорить о пользе предсказаний
модели.\\
\tabВажно следить за долей пользователей, для которых рекомендательная система
не может ничего порекомендовать. Такие ситуации могут происходить, например,
из-за отсутствия определенных признаков в модели или из-за низкой уверенности
модели. В таком случае необходимо отслеживать проблемы с покрытием в модели
рекомендаций.\\
%--------------------------------------------------------------------
\newpage
\section{Практическая часть}
\subsection{Работа с данными}
\tabДля построения алгоритмов рекомендательной системы был выбран датасет с информацией о предпочтениях $\approx$ 74 тысяч пользователей в просмотре аниме-сериалов. Каждый пользователь имеет возможность добавить сериал в список просмотренного и дать ему оценку от 1 до 10, где 10 значит, что пользователю понравился сериал. В данных содержатся рейтинги каждого пользователя для всех просмотренных им объектов в виде: user id — уникальный идентификационный ключ пользователя; anime id — уникальный идентификационный ключ просмотренного пользователем сериала; rating — рейтинг пользователя. Также в данных представлена информация о самих сериалах в виде: anime id; name — название сериала; genre — список жанров, к которому можно отнести объект; type — фильм, сериал, дополнительные материалы (в работе будет рассматриваться только тип сериал, так как таких данных большинство); episodes — количество эпизодов; rating — средний рейтинг пользователей; members — количество пользователей, посмотревших сериал.\\
\tabБыл проведен первичный анализ данных средствами Python3 и его библиотек: matplotlib, seaborn, pandas.\\
\tab\includegraphics[scale=0.8]{f3.png}\\
\tabИз круговой диаграммы видно, что, в процентном соотношении, в данных содержится больше информации об объектов с типом "TV" или, проще говоря, о сериалах.\\
\includegraphics[scale=0.7]{f4.png}\\
\tabИспользуя диаграмму размаха можно заметить, что медиана рейтинга для объектов с типом "TV" составляет ориентировочно 7 из 10 и является максимальной среди всех типов. Также можно заметить, что разброс первого и третьего квартиля, длина усов почти не отличаются от объекта типа "OVA", только находятся выше, что может говорить о более высоких оценках.\\
\tabИсходя из анализа графиков имеет смысл рассматривать только объекты типа "TV", то есть сериалы, так как данных о них больше и средний рейтинг выше, чем у остальных мультипликаций.\\
\tab\includegraphics[scale=0.8]{f5.png}\\
\tabВсего в датасете 3671 уникальных аниме-сериалов. Из таблицы видно, что у некоторых отсутствует информация о количестве эпизодов, таких меньше 100, поэтому на дальнейшие расчеты это влиять не будет. Средний рейтинг сериала действительно оказался близким к 7, он составляет 6.9. Маленькое значение среднеквадратического отклонения 0.864 означает, что значения рейтинга сгруппированы вокруг среднего.\\
\includegraphics[scale=0.7]{f6.png}\\
\tabИз графика зависимости среднего рейтинга от количества пользователей, посмотревших сериал, можно сделать вывод, что чем больше просмотров, тем больше положительных оценок и, в итоге, рейтинг сериала оказывается выше среднего. Следовательно, при построении рекомендательной системы не стоит опираться на рейтинг сериала, так как предложения алгоритма пользователю будут состоять из популярных мультипликаций и не будут основаны на его предпочтениях. Предпочтения пользователя определяются его собственными оценками.\\
\tab\includegraphics[scale=0.6]{f7.png}\\
\tabКорреляционная матрица подтверждает зависимость между рейтингом и количеством просмотров.\\
\tabИтак, исходя из проделанного анализа данных, было принято решение использовать предыдущие оценки пользователя для рекомендаций.\\
\includegraphics[scale=0.7]{f8.png}\\
\tabЧаще всего пользователи ставят оценку 8. 
%--------------------------------------------------------------------
\subsection{Разбиение выборки на обучающую и тестовую}
\tabВ любой задаче машинного обучения набор данных разбивается на две выборки: обучающую (train) и тестовую (test). Модель обучают на train выборке, а на test выборке модель проверяют, то есть получают некоторое предсказание. Это необходимо для того, чтобы оценить качество работы алгоритма на уже имеющихся данных и избежать переобучения/недообучения модели. \\
\tabСуществуют несколько способов разбиение данных на выборки. В работе используется разбиение функцией train\_test\_split из библиотеки Sklearn. Функция разбивает данные рандомным способом, что не всегда бывает корректным методом разбиения, но на данном этапе разработки рекомендательной системы этот метод подходит.\\
\tab\includegraphics[scale=0.6]{f9.png}\\
\tabТак выглядит часть train датасета. Заметим, что название объектов имеют тип строка. Такой тип данных не подходит для алгоритма, поэтому каждому уникальному названию необходимо сопоставить уникальный номер.
\tab\includegraphics[scale=0.6]{f10.png}\\
\tabИтоговый вид выборки.
%--------------------------------------------------------------------
\subsection{Создание матрицы рейтингов}
\tabСоставим матрицу рейтингов $R$ размерности $N\times M$, где $N$ — количество пользователей, а $M$ — количество сериалов. Это матрица, по одной из осей которой отложены все пользователи сервиса (Users), а по другой – сериалы (Items). На пересечении некоторых пар (user, item) данная матрица заполнена оценками (Ratings). Если в такой матрице хранить все значения, то есть не только сами оценки пользователей, но так же и нули, говорящие о том, что оценки не было, то в итоге такая матрица займет слишком много места, что увеличит время работы алгоритма и затраты памяти компьютера. Матрица  $R$ будет считаться разреженной матрицей, то есть матрицей с преимущественно нулевыми элементами. \\
\tabДля того, чтобы уменьшить матрицу рейтингов создается матрица без нулевых значений, но с сохранением первоначальных координат ячеек. При создании такой матрицы, достаточно знать координаты каждого ненулевого элемента. Координатами являются id пользователей и id аниме.\\
\includegraphics[scale=0.8]{f11.png}\\
\tabПример преобразования матрицы  $R$.
%--------------------------------------------------------------------
\subsection{Baseline prediction}
\tabДля начала попробуем предсказывать рейтинги пользователей простым способом. Найдем средний рейтинг для всех пользователей и всех сериалов. Для этого просуммируем все проставленные рейтинги и поделим на их количество:\\
\tab$\mu=\frac{1}{n}\sum_{u,i}r_{ui}$\\
\tabУже можно было бы сказать, что неизвестная нам оценка, которую поставит некий пользователь аниме-сериалу, равна среднему. Но это будет некорректное предположение, так как при этом не учитываются данные о пользователе.  Будем учитывать его предвзятость и переоценку/недооценку аниме-сериалу. Например, некоторые пользователи ставят в основном 10, а 9 для них - ужасный сериал; для некоторых пользователей наблюдается обратная ситуация: даже 5 для них — это высокая оценка.\\
\tabДля того, чтобы вычислить "сдвиг" в оценках пользователя $u$ относительно средней оценки $\mu$, достаточно вычесть из всех его оценок $r_{ui}$ среднюю оценку $\mu$, просуммировать результат и поделить на количество оценок $|I_u|$, который этот пользователь поставил. Так как не все пользователи ставили оценки, то был введен параметр $\alpha$, чтобы избежать деления на 0. Параметр $\alpha$ можно взять равным 1, но так как $\alpha$ является также и коэффициентом сглаживания, то было взято значение, равное $25$.\\
\tab$b_u=\frac{1}{|I_u|+\alpha}\sum_{i\in{}I_u}(r_{ui} - \mu), \qquad \alpha=25$\\
\tabАналогично вычислим "сдвиг" в оценивании аниме $i$, но при вычислении учтем еще и найденные ранее сдвиги в оценках пользователей. Также введем коэффициент сглаживания $\beta$ и примем его равным коэффициенту $\alpha$.\\
\tab$b_i=\frac{1}{|U_i|+\beta}\sum_{u^\prime\in{}U_i}(r_{u^\prime{}i} - b_{u^\prime} - \mu),  \qquad \beta=25$\\
\tabИтоговое предсказание оценки $r_{ui}$ пользователя $u$ объекту $i$:\\
\tab$\hat{r}_{ui}=\mu+b_u+b_i$\\
\tabСредняя оценка пользователей равна $7.882$. С учетом средней оценки вычислим "сдвиг" в оценке для каждого пользователя по формуле, описанной выше.\\
\tab\includegraphics[scale=0.8]{f12.png}\\
\tabИз матрицы сдвигов оценок видно, что, например, второй пользователь в среднем ставит оценку на 3 баллы меньше, чем средняя оценка всех пользователей. Это значит, что сериалу, которому обычный пользователь поставил бы оценку 8, наш поставит всего лишь 5. Именно из-за возникновения таких ситуаций необходимо делать поправку на предвзятость.\\
\tabСредняя оценка сериала равна $6.9$. Также вычислим "сдвиг" для объектов рекомендации.\\
\tab\includegraphics[scale=0.8]{f13.png}\\
\tabВ итоге объединим "сдвиги" пользователей и "сдвиги" объектов в единую матрицу. Тогда значение $b_{ui}$, находящееся на пересечении строки $u$ и столбца $i$, будет равно "сдвигу" оценивания аниме $i$ пользователем $u$ относительно средней оценки $\mu$.\\
\tabСложим среднюю оценку $\mu$ и все известные нам сдвиги $B$ в соответствии с формулой, описанной выше, и получим простую рекомендательную систему. Значение $r_{ui}$, находящееся на пересечении строки $u$ и столбца $i$ матрицы получившейся матрицы — оценка, которую поставит пользователь $u$ аниме-сериалу $i$.\\
\tab\includegraphics[scale=0.8]{f14.png}\\
\tabПосмотрим работу алгоритма на примере пользователя с $id=9910$.\\
\tab\includegraphics[scale=0.8]{f15.png}\\
\tabФункция выдает 10 рекомендаций в виде: название сериала, прогнозируемая оценка пользователя. В тестовой выборке, которая не учитывалась при построении прогноза, есть сериал "Shigatsu wa Kimi no Uso", который пользователь оценил в $8$ баллов. Предсказание алгоритма было $8.97$. Порядок рейтинга предсказан довольно точно.
%--------------------------------------------------------------------
\subsection{Использование схожести пользователей}
\tabВ предыдущем алгоритме предсказывали рейтинг пользователей, отталкиваясь от среднего рейтинга всех пользователей. Поэтому, даже если пользователю $u$ нравится только жанр ужасы, то при вычислении его оценок также учитывались оценки тех пользователей, кто больше любит жанр комедия, что неправильно. Необходимо модифицировать алгоритм Baseline prediction: во-первых, нужно учитывать только $N$ похожих пользователей (множество $U_{sim}$); во-вторых, каждый рейтинг будет учитывать с весом, равным схожести пользователей.\\
\\
\tab$\hat{r}_{ui}=\frac{\sum_{u^\prime \in U_{sim}}sim(u,u^\prime)r_{u^\prime{}i}}{\sum_{u^\prime\in U_{sim}}|sim(u,u^\prime)|}$\\
\\
\tabНемного улучшим алгоритм: усредним не оценки похожих пользователей, а их "сдвиги" в оценках, и добавим это к средней оценке пользователя $u$.\\
\\
\tab$\hat{r}_{ui}=\bar{r}_u+\frac{\sum_{u^\prime}sim(u,u^\prime)(r_{u^\prime{}i}-\bar{r_{u^\prime})}}{\sum_{u^\prime}|sim(u,u^\prime)|}$\\
\\
\tabЗдесь $\bar{r}_u$ - средний рейтинг пользователя $u$.\\
\tabИспользуем косинусную близость:\\
\tab${\displaystyle {\text{similarity}}=\cos(\theta )={ A  \cdot  B   \over \| A  \|\| B \|}={\frac {\sum \limits _{i=1}^{n}{A_{i}B_{i}}}{{\sqrt {\sum \limits _{i=1}^{n}{A_{i}^{2}}}}{\sqrt {\sum \limits _{i=1}^{n}{B_{i}^{2}}}}}},}$\\
\tabДля облегчения задачи нормализуем вектора рейтингов для каждого пользователя.\\
\tab$R^\prime=r_{ui}-\mu-b_u-b_i.$\\
\tabРеализована функция, которая возвращает топ 10 аниме-сериалов, похожих по аудитории. Стоит отметить, что схожесть вычисляется не по жанру, а по группам пользователей.\\
\tab\includegraphics[scale=0.8]{f16.png}\\
\tabАлгоритм вернул топ 10 сериалов, похожих на "Naruto". Замечу, что рекомендованные мультипликации, как и первоначальный сериал, ориентированы на зрителей 12+, поэтому аудитория у них, действительно, схожа.\\
\tabИспользую матрицу близости пользователей, найдем самых близких $N$ к пользователю с $id=9910$ и по ним определим рейтинг.
\tab\includegraphics[scale=0.8]{f17.png}\\
\tabКак и в первом случае, сравним полученные рекомендации с test частью выборки. Сериалу "Baccano!", "Clannad: After Story" пользователь поставил 9/10. Следовательно, рекомендации действительно обоснованы.\\
%--------------------------------------------------------------------
\subsection{Латентные признаки: SVD}
\tabЕсть возможность использовать для предсказания знания о пользователе, которые он сам сообщил. Это может быть пол, возраст, любимые фильмы. Но что делать, если пользователь ничего не указал? В этом случае помогает использование латентных (скрытых) признаков. Например, на основе анализа оценок пользователей можно заметить, что User 1 предпочитает больше мелодрамы, тогда как User 2 любит больше экшн фильмы, хотя ни тот, ни другой нигде это не указали. Это и есть латентные признаки.\\
\tabОдин из способов "достать" такие признаки - разложение (факторизация) матрицы\\
\tab$R=UI^T,$\\
где $R\in\mathbb{R}^{u\times{}i}$, $U\in\mathbb{R}^{u\times{}k}$ и $I\in\mathbb{R}^{i\times{}k}$. Такого разложения можно добиться, используя SVD разложение.\\
\tabПример работы алгоритма SVD:\\
\tab\includegraphics[scale=0.8]{f18.png}\\
%--------------------------------------------------------------------
\newpage
\section{Заключение}
\tabВ работе были проанализированы первичные данные и на основе анализа были сделаны корректировки и выводы о том, как эффективнее использовать данную информацию при написания алгоритмов рекомендательной системы. \\
\tabБыли реализованы три метода предсказания товара, который понравится пользователю. Baseline prediction был самым простым и понятным в реализации. С его помощью некоторому определенному пользователю был порекомендован сериал, который пользователь оценил в 8 баллов из 10 при предсказанном рейтинге 8.97.\\
\tabИспользуя схожесть пользователя для того же клиента онлайн сайта, было предсказано два сериала, оценка которых в конечном итоге составила 9/10.\\
\tabПроблематика полной оценки работы алгоритмов заключается в нехватке данных о пользователе: нельзя сказать, какой рейтинг поставил клиент получившимся рекомендациям. Однако, факт того, что в некоторых случаях предсказанная и реальная оценка совпадали, дает право сделать вывод о том, что построенная рекомендательная система работает.\\
\tabРаботу алгоритмов можно улучшить, обработав больший массив данных и посмотрев метрики для рекомендации сериалов в онлайн режиме.
%--------------------------------------------------------------------
\newpage
\section{Список использованных источников}
\renewcommand{\refname}{}
\begin{thebibliography}{7}
\bibitem{i1} \href{https://datajobs.com/data-science-repo/Recommender-Systems-[Netflix].pdf}{Yehuda Koren, Robert Bell and Chris Volinsky. MATRIX FACTORIZATION TECHNIQUES FOR RECOMMENDER SYSTEMS - 2009.}
\bibitem{i2} \href{http://files.grouplens.org/papers/FnT\%20CF\%20Recsys\%20Survey.pdf}{Michael D. Ekstrand, John T. Riedl and Joseph A. Konstan. Collaborative Filtering Recommender Systems - Foundations and Trends in Human-Computer Interactions Vol. 4, No. 2 (2010) p. 81–173.}
\end{thebibliography}

%--------------------------------------------------------------------
\newpage
\section{Приложение}
\tabИсходный код можно найти по \href{https://github.com/dokapoka/paper_recomm_systems}{ссылке}.

 \end{document}  
